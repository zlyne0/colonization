package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.xml.sax.SAXException;

import com.badlogic.gdx.utils.ObjectIntMap;
import com.badlogic.gdx.utils.ObjectIntMap.Entry;

import net.sf.freecol.common.model.Unit.UnitState;
import net.sf.freecol.common.model.player.Market;
import net.sf.freecol.common.model.player.Player;
import net.sf.freecol.common.model.player.TransactionEffectOnMarket;
import net.sf.freecol.common.model.specification.Ability;
import net.sf.freecol.common.model.specification.BuildableType;
import net.sf.freecol.common.model.specification.BuildingType;
import net.sf.freecol.common.model.specification.FoundingFather;
import net.sf.freecol.common.model.specification.GameOptions;
import net.sf.freecol.common.model.specification.GoodsType;
import net.sf.freecol.common.model.specification.Modifier;
import net.sf.freecol.common.model.specification.RequiredGoods;
import net.sf.freecol.common.model.specification.UnitTypeChange.ChangeType;
import net.sf.freecol.common.util.StringUtils;
import promitech.colonization.Direction;
import promitech.colonization.NewTurnContext;
import promitech.colonization.savegame.ObjectFromNodeSetter;
import promitech.colonization.savegame.XmlNodeAttributes;
import promitech.colonization.savegame.XmlNodeParser;
import promitech.colonization.ui.resources.Messages;
import promitech.colonization.ui.resources.StringTemplate;

public class Colony extends Settlement {
	public static final int NEVER_COMPLETE_BUILD = -1;
    public static final int LIBERTY_PER_REBEL = 200;

    /** Reasons for not building a buildable. */
    public static enum NoBuildReason {
        NONE,
        NOT_BUILDING,
        NOT_BUILDABLE,
        POPULATION_TOO_SMALL,
        MISSING_BUILD_ABILITY,
        MISSING_ABILITY,
        WRONG_UPGRADE,
        COASTAL,
        LIMIT_EXCEEDED
    }
    
    GoodsContainer goodsContainer;
    public final MapIdEntities<Building> buildings = new MapIdEntities<Building>();
    public final MapIdEntities<ColonyTile> colonyTiles = new MapIdEntities<ColonyTile>();
    public final List<ColonyBuildingQueueItem> buildingQueue = new ArrayList<ColonyBuildingQueueItem>(); 
    
    final ObjectWithFeatures colonyUpdatableFeatures;
    
    private final ColonyProduction colonyProduction;
    final List<Unit> colonyWorkers = new ArrayList<Unit>();
    private int sonsOfLiberty = 0;
    private int tories = 0;
    private int productionBonus = 0;
    
    /**
     * The number of liberty points.  Liberty points are an
     * abstract game concept.  They are generated by but are not
     * identical to bells, and subject to further modification.
     */
    protected int liberty = 0;
    /**
     * The number of immigration points.  Immigration points are an
     * abstract game concept.  They are generated by but are not
     * identical to crosses.
     */
    protected int immigration;
    
    public Colony(String id) {
    	this.id = id;
    	colonyUpdatableFeatures = new ObjectWithFeatures("tmp" + id);
    	colonyProduction = new ColonyProduction(this);
    }

    public String toString() {
    	return "id=" + id + ", name=" + getName();
    }
    
    public int getColonyUnitsCount() {
		return colonyWorkers.size();
	}

    public boolean canReducePopulation() {
    	return getColonyUnitsCount() > colonyUpdatableFeatures.applyModifier(Modifier.MINIMUM_COLONY_SIZE, 0); 
    }
    
    public void updateModelOnWorkerAllocationOrGoodsTransfer() {
    	colonyProduction.setAsNeedUpdate();
    }

    public boolean isUnitInColony(Unit unit) {
        for (Building building : buildings.entities()) {
            if (building.workers.containsId(unit)) {
                return true;
            }
        }
        if (isUnitOnTerrain(unit)) {
        	return true;
        }
        return false;
    }
    
	public boolean isUnitOnTerrain(Unit unit) {
		return unitWorkingTerrain(unit) != null;
	}

	public ColonyTile unitWorkingTerrain(Unit unit) {
        for (ColonyTile colonyTile : colonyTiles.entities()) {
            if (colonyTile.getWorker() != null && unit.equalsId(colonyTile.getWorker())) {
            	return colonyTile;
            }
        }
        return null;
	}
	
    public void updateColonyPopulation() {
    	colonyWorkers.clear();
    	for (Building building : buildings.entities()) {
    		colonyWorkers.addAll(building.workers.entities());
    	}
    	for (ColonyTile colonyTile : colonyTiles.entities()) {
    		if (colonyTile.getWorker() != null) {
    			colonyWorkers.add(colonyTile.getWorker());
    		}
    	}
    	updateSonOfLiberty();
    	updateProductionBonus();
    }
    
    public void updateColonyFeatures() {
    	colonyUpdatableFeatures.clear();
    	if (isCoastland()) {
    		colonyUpdatableFeatures.addAbility(Ability.HAS_PORT_ABILITY);
    	}
    	for (Building b : buildings.entities()) {
    		colonyUpdatableFeatures.addFeatures(b.buildingType);
    	}
    	for (FoundingFather ff : owner.foundingFathers.entities()) {
    	    colonyUpdatableFeatures.addFeatures(ff);
    	}
    }
    
    @Override
    public boolean hasAbility(String abilityCode) {
        return colonyUpdatableFeatures.hasAbility(abilityCode);
    }
    
	@Override
	public int applyModifiers(String modifierCode, int val) {
		return (int)colonyUpdatableFeatures.applyModifier(modifierCode, (float)val);
	}

    private String getStockadeKey() {
    	for (Building building : buildings.entities()) {
    		if (building.buildingType.hasModifier(Modifier.DEFENCE)) {
    			return StringUtils.lastPart(building.buildingType.getId(), ".");
    		}
    	}
    	return null;
    }

	@Override
	public boolean isColony() {
		return true;
	}
    
    public String getImageKey() {
        int count = getColonyUnitsCount();
        String key = (count <= 3) ? "small"
            : (count <= 7) ? "medium"
            : "large";
        String stockade = getStockadeKey();
        if (stockade != null) {
            key += "." + stockade;
        }
        return "model.settlement." + key + ".image";
    }

    public void addWorkerToBuilding(Building building, Unit unit) {
    	unit.setState(UnitState.IN_COLONY);
    	UnitRole defaultUnitRole = Specification.instance.unitRoles.getById(UnitRole.DEFAULT_ROLE_ID);
    	changeUnitRole(unit, defaultUnitRole);
        building.workers.add(unit);
    }
    
    public void addWorkerToTerrain(ColonyTile destColonyTile, Unit unit) {
    	unit.setState(UnitState.IN_COLONY);
    	UnitRole defaultUnitRole = Specification.instance.unitRoles.getById(UnitRole.DEFAULT_ROLE_ID);
    	changeUnitRole(unit, defaultUnitRole);
        destColonyTile.setWorker(unit);
    }
    
    public List<GoodMaxProductionLocation> determinePotentialTerrainProductions(Unit unit) {
        if (!unit.isPerson()) {
            return Collections.emptyList();
        }
        ColonyTile terrain = unitWorkingTerrain(unit);
        if (terrain == null) {
        	return Collections.emptyList();
        }
    	return colonyProduction.determinePotentialTerrainProductions(terrain, unit);
    }
    
    public List<GoodMaxProductionLocation> determinePotentialMaxGoodsProduction(Unit unit) {
        if (!unit.isPerson()) {
            return Collections.emptyList();
        }
        List<GoodMaxProductionLocation> determinePotentialMaxGoodsProduction = colonyProduction.determinePotentialMaxGoodsProduction(unit);
        return determinePotentialMaxGoodsProduction;
    }

    public void changeUnitRole(Unit unit, UnitRole newUnitRole) {
    	if (!newUnitRole.isAvailableTo(unit.unitType)) {
    		throw new IllegalStateException("can not change role for unit: " + unit + " from " + unit.unitRole + " to " + newUnitRole);
    	}
    	ProductionSummary required = unit.unitRole.requiredGoodsToChangeRoleTo(newUnitRole);
    	
    	if (!goodsContainer.hasGoodsQuantity(required)) {
    		throw new IllegalStateException("warehouse do not have enough goods " + required);
    	}
    	unit.changeRole(newUnitRole);
    	goodsContainer.decreaseGoodsQuantity(required);
    }
    
    public GoodsContainer getGoodsContainer() {
        return goodsContainer;
    }
    
	@Override
	public void addGoods(String goodsTypeId, int quantity) {
		goodsContainer.increaseGoodsQuantity(goodsTypeId, quantity);
	}
    
    public void increaseWorkersExperience() {
        for (ColonyTile colonyTile : colonyTiles.entities()) {
            if (colonyTile.getWorker() != null && !colonyTile.getWorker().isExpert()) {
                Unit worker = colonyTile.getWorker();
                increaseExperienceForWorker(colonyTile, worker, 1);
            }
        }
        for (Building building : buildings.entities()) {
            for (Unit worker : building.workers.entities()) {
                if (worker.isExpert()) {
                    continue;
                }
                increaseExperienceForWorker(building, worker, building.workers.size());
            }
        }
    }
    
    private void increaseExperienceForWorker(ProductionLocation productionLocation, Unit worker, int prodLocWorkersAmount) {
        ProductionSummary realProduction = productionSummary(productionLocation).realProduction;
        System.out.println("production location [" + productionLocation + "] produce [" + realProduction + "]");
        for (Entry<String> entry : realProduction.entries()) {
            UnitType goodsExpertUnitType = Specification.instance.expertUnitTypeByGoodType.get(entry.key);
            if (goodsExpertUnitType != null && worker.unitType.canBeUpgraded(goodsExpertUnitType, ChangeType.EXPERIENCE)) {
                int experience = entry.value / prodLocWorkersAmount;
                System.out.println("worker [" + worker + "] gain " + experience + " experience to be " + goodsExpertUnitType );
                worker.gainExperience(experience);
            }
        }
    }

    public void removeExcessedStorableGoods() {
        int warehouseCapacity = getWarehouseCapacity();
        for (GoodsType gt : Specification.instance.goodsTypes.entities()) {
            if (!gt.isStorable()) {
                continue;
            }
            if (gt.isFood()) {
                continue;
            }
            int goodsAmount = goodsContainer.goodsAmount(gt);
            if (goodsAmount > warehouseCapacity) {
                int wasteAmount = goodsAmount - warehouseCapacity;
                goodsContainer.decreaseGoodsQuantity(gt, wasteAmount);
                owner.eventsNotifications.addWarehouseWasteNotification(this, gt, wasteAmount);
            }
        }
    }
    
    public void notificationsAboutLackOfResources() {
        int foodProdCons = colonyProduction.globalProductionConsumption().getQuantity(GoodsType.FOOD);
        if (foodProdCons < 0) {
            // food consumption is greater then production
            int quantityToConsume = -foodProdCons;
            int storedAfterConsume = goodsContainer.goodsAmount(GoodsType.FOOD) - quantityToConsume;
            
            if (storedAfterConsume >= 0) {
                int turns = goodsContainer.goodsAmount(GoodsType.FOOD) / quantityToConsume;
                if (turns < 3) {
                    // TODO: notification model.colony.famineFeared
                    System.out.println("Famine feared in %colony%. Only %number% turns of food left.");
                }
            } else {
                // TODO: model.colony.colonistStarved
                // TODO: model.colony.colonyStarved
                System.out.println("A colonist has starved to death in %colony%!");
            }
        }
        
        for (Building building : buildings.entities()) {
            ProductionConsumption productionSummary = productionSummary(building);

            for (Entry<String> entry : productionSummary.baseProduction.entries()) {
                if (GoodsType.isFoodGoodsType(entry.key)) {
                    continue;
                }
                int quantityToConsume = -entry.value;
                int afterConsume = goodsContainer.goodsAmount(entry.key) - quantityToConsume;
                if (afterConsume == 0) {
                    // TODO: model.building.notEnoughInput
                    System.out.println("### The %building% in %colony% has stopped production because of missing " + entry.key + ".");
                } else {
                    if (afterConsume < quantityToConsume) {
                        // TODO: model.building.warehouseEmpty
                        //System.out.println("building " + building);
                        System.out.println("### There are now less than " + (quantityToConsume) + " units of " + entry.key + " in your warehouse in %colony%.");
                    }
                }
            }
        }
    }
    
	public void calculateSonsOfLiberty() {
		int oldSonsOfLiberty = sonsOfLiberty;
		ProductionSummary gpc = colonyProduction.globalProductionConsumption();
		int bells = gpc.getQuantity(GoodsType.BELLS);

        System.out.println("calculateSonsOfLiberty: bells: " + bells + ", liberty: " + liberty + ", sonsOfLiberty: " + sonsOfLiberty + ", tories: " + tories);
		
		owner.modifyLiberty(bells);
		liberty = Math.max(0, liberty + bells);
		
		updateSonOfLiberty();
		updateProductionBonus();
        boolean capped = Specification.options.getBoolean(GameOptions.BELL_ACCUMULATION_CAPPED);
        if (capped && sonsOfLiberty >= 100) {
            liberty = LIBERTY_PER_REBEL * getColonyUnitsCount();
        }

		if (sonsOfLiberty / 10 != oldSonsOfLiberty / 10) {
			String templateName = null;
			if (sonsOfLiberty > oldSonsOfLiberty) {
				templateName = "model.colony.SoLIncrease";
			} else {
				templateName = "model.colony.SoLDecrease";
			}
			
			// TODO: add notification
			StringTemplate t = StringTemplate.template(templateName)
					.add("%colony%", this.getName())
					.addAmount("%newSoL%", sonsOfLiberty);
			String st = Messages.message(t);
			System.out.println("st = "  + st);
		}
        System.out.println("calculateSonsOfLiberty: bells: " + bells + ", liberty: " + liberty + ", sonsOfLiberty: " + sonsOfLiberty + ", tories: " + tories);
	}
    
	public void calculateImmigration() {
        ProductionSummary gpc = colonyProduction.globalProductionConsumption();
        int crosses = gpc.getQuantity(GoodsType.CROSSES);
        immigration += crosses;
	    owner.modifyImmigration(crosses);
	}
	
    public ProductionConsumption productionSummary(ProductionLocation productionLocation) {
    	return colonyProduction.productionConsumptionForObject(productionLocation.getId());
    }
    
    public ProductionSummary productionSummary() {
    	return colonyProduction.globalProductionConsumption();
    }
    
	public void increaseWarehouseByProduction() {
		goodsContainer.increaseGoodsQuantity(productionSummary());
	}
    
    public void initMaxPossibleProductionOnTile(Tile tile) {
    	for (ColonyTile colonyTile : colonyTiles.entities()) {
    		if (colonyTile.equalsId(tile)) {
    			initMaxPossibleProductionOnTile(colonyTile);
    			updateModelOnWorkerAllocationOrGoodsTransfer();
    		}
    	}
    }
    
	public void initMaxPossibleProductionOnTile(ColonyTile aColonyTile) {
		if (aColonyTile.notEqualsId(tile) && aColonyTile.getWorker() == null) {
			return;
		}
		System.out.println("maxPossibleProductionOnTile: forTile: " + aColonyTile.tile.getType().productionInfo);
		ProductionInfo maxPossibleProductionOnTile = maxPossibleProductionOnTile(aColonyTile.getWorker(), aColonyTile.tile);

		System.out.println("maxPossibleProductionOnTile: maxProductions: " + maxPossibleProductionOnTile);
		
		aColonyTile.productionInfo.writeMaxProductionFromAllowed(maxPossibleProductionOnTile, aColonyTile.tile.getType().productionInfo);
		
		System.out.println("maxPossibleProductionOnTile: maxProductionType: " + aColonyTile.productionInfo);
	}
	
	private ProductionInfo maxPossibleProductionOnTile(Unit aUnit, Tile aTile) {
		ProductionInfo productionInfo = aTile.getType().productionInfo;
		ProductionInfo productionSummaryForWorker = productionInfo.productionSummaryForWorker(aUnit);
		productionSummaryForWorker.applyModifiers(owner.foundingFathers.entities());
		productionSummaryForWorker.applyTileImprovementsModifiers(aTile);
		return productionSummaryForWorker;
	}
	
    public int getWarehouseCapacity() {
    	return (int)colonyUpdatableFeatures.applyModifier(Modifier.WAREHOUSE_STORAGE, 0);
    }

    public int sonsOfLiberty() {
        return sonsOfLiberty;
    }

    public int rebels() {
        return (int)Math.floor(0.01 * sonsOfLiberty * getColonyUnitsCount());
    }

    public int tories() {
        return tories;
    }

    public int productionBonus() {
        return productionBonus;
    }
    
    /**
     * Update the colony's production bonus.
     *
     * @return True if the bonus changed.
     */
    protected boolean updateProductionBonus() {
        final int veryBadGovernment = Specification.options.getIntValue(GameOptions.VERY_BAD_GOVERNMENT_LIMIT);
        final int badGovernment = Specification.options.getIntValue(GameOptions.BAD_GOVERNMENT_LIMIT);
        final int veryGoodGovernment = Specification.options.getIntValue(GameOptions.VERY_GOOD_GOVERNMENT_LIMIT);
        final int goodGovernment = Specification.options.getIntValue(GameOptions.GOOD_GOVERNMENT_LIMIT);
        int newBonus = (sonsOfLiberty >= veryGoodGovernment) ? 2
            : (sonsOfLiberty >= goodGovernment) ? 1
            : (tories > veryBadGovernment) ? -2
            : (tories > badGovernment) ? -1
            : 0;
        if (productionBonus != newBonus) {
            productionBonus = newBonus;
            return true;
        }
        return false;
    }
    
    private void updateSonOfLiberty() {
        int uc = getColonyUnitsCount();
        sonsOfLiberty = calculateSoLPercentage(uc, liberty);
        tories = uc - rebels();
    }
    
    /**
     * Gets the number of units that would be good to add/remove from this
     * colony.  That is the number of extra units that can be added without
     * damaging the production bonus, or the number of units to remove to
     * improve it.
     *
     * @return The number of units to add to the colony, or if negative
     *      the negation of the number of units to remove.
     */
    public int getPreferredSizeChange() {
        int i, limit, pop = getColonyUnitsCount();
        if (productionBonus < 0) {
            limit = pop;
            for (i = 1; i < limit; i++) {
                if (governmentChange(pop - i) == 1) break;
            }
            return -i;
        } else {
            limit = Specification.options.getIntValue(GameOptions.BAD_GOVERNMENT_LIMIT);
            for (i = 1; i < limit; i++) {
                if (governmentChange(pop + i) == -1) break;
            }
            return i - 1;
        }
    }
    
    /**
     * Returns 1, 0, or -1 to indicate that government would improve,
     * remain the same, or deteriorate if the colony had the given
     * population.
     *
     * @param unitCount The proposed population for the colony.
     * @return 1, 0 or -1.
     */
    public int governmentChange(int unitCount) {
        final int veryBadGovernment = Specification.options.getIntValue(GameOptions.VERY_BAD_GOVERNMENT_LIMIT);
        final int badGovernment = Specification.options.getIntValue(GameOptions.BAD_GOVERNMENT_LIMIT);
        final int veryGoodGovernment = Specification.options.getIntValue(GameOptions.VERY_GOOD_GOVERNMENT_LIMIT);
        final int goodGovernment = Specification.options.getIntValue(GameOptions.GOOD_GOVERNMENT_LIMIT);

        int rebelPercent = calculateSoLPercentage(unitCount, liberty);
        int rebelCount = rebels();
        int loyalistCount = unitCount - rebelCount;

        int result = 0;
        if (rebelPercent >= veryGoodGovernment) { // There are no tories left.
            if (sonsOfLiberty < veryGoodGovernment) {
                result = 1;
            }
        } else if (rebelPercent >= goodGovernment) {
            if (sonsOfLiberty >= veryGoodGovernment) {
                result = -1;
            } else if (sonsOfLiberty < goodGovernment) {
                result = 1;
            }
        } else {
            if (sonsOfLiberty >= goodGovernment) {
                result = -1;
            } else { // Now that no bonus is applied, penalties may.
                if (loyalistCount > veryBadGovernment) {
                    if (tories <= veryBadGovernment) {
                        result = -1;
                    }
                } else if (loyalistCount > badGovernment) {
                    if (tories <= badGovernment) {
                        result = -1;
                    } else if (tories > veryBadGovernment) {
                        result = 1;
                    }
                } else {
                    if (tories > badGovernment) {
                        result = 1;
                    }
                }
            }
        }
        return result;
    }
    
    /**
     * Calculate the SoL membership percentage of the colony based on the
     * number of colonists and liberty.
     *
     * @param uc The proposed number of units in the colony.
     * @param liberty The amount of liberty.
     * @return The percentage of SoLs, negative if not calculable.
     */
    private int calculateSoLPercentage(int uc, int liberty) {
        if (uc <= 0) {
            return -1;
        }
        float membership = (liberty * 100.0f) / (LIBERTY_PER_REBEL * uc);
        membership = owner.applyModifier(Modifier.SOL, membership);
        
        if (membership < 0.0f) {
            membership = 0.0f;
        } else if (membership > 100.0f) {
            membership = 100.0f;
        }
        return (int)membership;
    }
    

    public void initColonyTilesTile(Tile colonyTile, Map map) {
        for (ColonyTile ct : colonyTiles.entities()) {
            boolean foundTileForColonyTile = false; 
            for (Direction direction : Direction.allDirections) {
                if (ct.equalsId(colonyTile)) {
                    ct.tile = colonyTile;
                    foundTileForColonyTile = true;
                    break;
                }
                Tile borderTile = map.getTile(colonyTile.x, colonyTile.y, direction);
                if (ct.equalsId(borderTile)) {
                    ct.tile = borderTile;
                    foundTileForColonyTile = true;
                    break;
                }
            }
            if (foundTileForColonyTile == false) {
                throw new IllegalStateException("can not find Tile for ColonyTile: " + ct);
            }
            
        	if (ct.tile.getType().isWater()) {
        		coastland = true;
        	}
        }
    }
    
    public void addItemToBuildingQueue(ColonyBuildingQueueItem item) {
    	buildingQueue.add(item);
    }
    
    public void removeItemFromBuildingQueue(ColonyBuildingQueueItem item) {
        buildingQueue.remove(item);
    }
    
	public BuildableType getFirstItemInBuildingQueue() {
        if (buildingQueue.isEmpty()) {
            return null;
        }
        return buildingQueue.get(0).getType();
	}
	
    public void buildableBuildings(List<ColonyBuildingQueueItem> items) {
    	// TODO: przebudowa metoday aby kozystac z getNoBuildReason
    	Collection<BuildingType> buildingsTypes = Specification.instance.buildingTypes.sortedEntities();
    	for (BuildingType bt : buildingsTypes) {
    		if (!colonyUpdatableFeatures.hasAbilitiesRequiredFrom(bt)) {
    			System.out.println("" + bt + ": colony do not have required ability");
    			continue;
    		}
    		if (isOnBuildingQueue(bt)) {
    			System.out.println("" + bt + " already on building queue list");
    			continue;
    		}
    		if (isBuildingAlreadyBuilt(bt)) {
    			System.out.println("" + bt + " has already built");
    			continue;
    		}
    		if (!isBuildingCanBeBuiltBecauseOfLevel(bt)) {
    			System.out.println("" + bt + " build level not accessible");
    			continue;
    		}
    		// TODO: usuniecie na rzecz hasPort model.ability.hasPort
    		if (bt.hasAbility(Ability.COASTAL_ONLY) && !isCoastland()) {
    			System.out.println("" + bt + " can be built only on coastland");
    			continue;
    		}
    		if (bt.getRequiredPopulation() > getColonyUnitsCount()) {
    			System.out.println("" + bt + " required more colony units");
    			continue;
    		}
    		items.add(new ColonyBuildingQueueItem(bt));
    	}
    }
    
    public void buildableUnits(List<ColonyBuildingQueueItem> items) {
    	Collection<UnitType> unitTypes = Specification.instance.unitTypes.sortedEntities();
    	for (UnitType unitType : unitTypes) {
    		if (unitType.getId().equals("model.unit.flyingDutchman")) {
    			System.getProperties();
    		}
    		if (!colonyUpdatableFeatures.canApplyAbilityToObject(Ability.BUILD, unitType)) {
    			System.out.println("" + unitType + " can not be built because of buildable ability");
    			continue;
    		}
    		if (!colonyUpdatableFeatures.hasAbilitiesRequiredFrom(unitType)) {
    			System.out.println("" + unitType + " can not be built because of required abilities");
    			continue;
    		}
    		if (UnitType.WAGON_TRAIN.equals(unitType.getId())) {
    			if (owner.unitTypeCount(unitType) >= owner.settlements.size()) {
    				continue;
    			}
    		}
    		items.add(new ColonyBuildingQueueItem(unitType));
    	}
    }
    
    private boolean isBuildingCanBeBuiltBecauseOfLevel(BuildingType buildingType) {
    	for (Building building : buildings.entities()) {
    		if (building.buildingType.isTheSameRoot(buildingType)) {
    			if (building.buildingType.canUpgradeTo(buildingType)) {
    				return true;
    			} else {
    				return false;
    			}
    		}
    	}
    	// does not find building
    	return buildingType.isRoot();
    }
    
    public boolean isBuildingAlreadyBuilt(BuildingType buildingType) {
    	for (Building building : buildings.entities()) {
    		if (building.buildingType.equalsId(buildingType)) {
    			return true;
    		}
    	}
    	return false;
    }
    
    private boolean isOnBuildingQueue(BuildingType buildingType) {
    	for (ColonyBuildingQueueItem item : buildingQueue) {
    		if (buildingType.equalsId(item.getId())) {
    			return true;
    		}
    	}
    	return false;
    }
    
	public int getPriceForBuilding(BuildableType buildableType) {
		List<RequiredGoods> requiredGoods = buildableType.requiredGoods();
		
		Market market = owner.market();
		
		int sum = 0;
		for (RequiredGoods rg : requiredGoods) {
			int warehouseGoodsAmount = goodsContainer.goodsAmount(rg.getId());
			if (rg.amount > warehouseGoodsAmount) {
				int requireGoods = rg.amount - warehouseGoodsAmount;
				sum += market.buildingGoodsPrice(rg.goodsType, requireGoods);
			}
		}
		return sum;
	}

	public void payForBuilding(BuildableType buildableType, Game game) {
		if (!Specification.options.getBoolean(GameOptions.PAY_FOR_BUILDING)) {
			throw new IllegalStateException("Pay for building is disabled");
		}
		
		Market ownerMarket = owner.market();
		for (RequiredGoods requiredGood : buildableType.requiredGoods()) {
			int reqDiffAmount = requiredGood.amount - goodsContainer.goodsAmount(requiredGood.goodsType);
			if (reqDiffAmount <= 0) {
				continue;
			}
			TransactionEffectOnMarket effectOnMarket = ownerMarket.buyGoods(owner, requiredGood.goodsType, reqDiffAmount, goodsContainer);
			
			game.propagateBuyToEuropeanMarkets(owner, requiredGood.goodsType, effectOnMarket.goodsModifiedMarket);
			if (effectOnMarket.priceChanged()) {
				owner.eventsNotifications.addPriceChangeNotification(requiredGood.goodsType, effectOnMarket.beforePrice, effectOnMarket.afterPrice);
			}
		}
		updateModelOnWorkerAllocationOrGoodsTransfer();
	}
	
	public void buildBuildings(Game game, NewTurnContext newTurnContext) {
	    BuildableType buildableType = getFirstItemInBuildingQueue();
		if (buildableType == null) {
			return;
		}
		ObjectIntMap<String> requiredTurnsForGoods = new ObjectIntMap<String>(buildableType.requiredGoods().size());
		int turnsToGatherResourcesForBuild = getTurnsToComplete(buildableType, requiredTurnsForGoods);
		if (turnsToGatherResourcesForBuild == NEVER_COMPLETE_BUILD) {
			neverFinishBuildingNotification(buildableType, requiredTurnsForGoods);
			return;
		} 
		if (turnsToGatherResourcesForBuild == 0) {
			NoBuildReason noBuildReason = getNoBuildReason(buildableType);
			if (NoBuildReason.NONE != noBuildReason) {
				finishBuildingProblemNotification(buildableType, noBuildReason);
			} else {
				finishBuilding(game, newTurnContext, buildableType);
			}
		}
	}

    private void finishBuildingProblemNotification(BuildableType buildableType, NoBuildReason noBuildReason) {
        StringTemplate st;
        switch (noBuildReason) {
        case LIMIT_EXCEEDED:
        	st = StringTemplate.template("model.limit.wagonTrains.description");
        	break;
        case POPULATION_TOO_SMALL:
        	st = StringTemplate.template("model.colony.buildNeedPop")
                .add("%colony%", getName())
                .addName("%building%", buildableType);
        	break;
        default:
        	st = StringTemplate.template("colonyPanel.unbuildable")
        		.add("%colony%", getName())
        		.addName("%object%", buildableType);
        	break;
        }
        // TODO: notification
        System.out.println("no build reason '" + noBuildReason + "' " + Messages.message(st));
    }

    private void neverFinishBuildingNotification(BuildableType buildableType, ObjectIntMap<String> requiredTurnsForGoods) {
        for (RequiredGoods requiredGood : buildableType.requiredGoods()) {
        	int turnsForGoodsType = requiredTurnsForGoods.get(requiredGood.getId(), -1);
        	if (turnsForGoodsType == NEVER_COMPLETE_BUILD) {
        		int amount = requiredGood.amount - goodsContainer.goodsAmount(requiredGood.getId());
        		
        		// TODO: notification
        		StringTemplate st = StringTemplate.template("model.colony.buildableNeedsGoods")
        			.addName("%goodsType%", requiredGood.getId())
        			.addAmount("%amount%", amount)
        			.add("%colony%", getName())
        			.addName("%buildable%", buildableType.getId());
        		System.out.println("never complete building = " + Messages.message(st) );
        		break;
        	}
        }
    }

	private void finishBuilding(Game game, NewTurnContext newTurnContext, BuildableType buildableType) {
		if (buildableType.isUnitType()) {
			Unit unit = new Unit(
				game.idGenerator.nextId(Unit.class), 
				(UnitType)buildableType,
				Specification.instance.unitRoles.getById(UnitRole.DEFAULT_ROLE_ID),
				owner
			);
			tile.units.add(unit);
			unit.setLocation(tile);
			
			StringTemplate st = UnitLabel.getPlainUnitLabel(unit);
			// TODO: notification
			System.out.println("XXX new unit = " + Messages.message(st));
		}
		if (buildableType.isBuildingType()) {
			BuildingType buildingType = (BuildingType)buildableType;
			BuildingType from = buildingType.getUpgradesFrom();
			if (from != null) {
				Building building = findBuildingByType(from.getId());
				building.upgrade(buildingType);
			} else {
				Building building = new Building(game.idGenerator.nextId(Building.class), buildingType);
				buildings.add(building);
			}
			
			if (buildableType.hasModifier(Modifier.DEFENCE)) {
				newTurnContext.setRequireUpdateMapModel();
			}
			updateColonyFeatures();
			updateColonyPopulation();
			updateModelOnWorkerAllocationOrGoodsTransfer();
			
			// TODO: notification
			StringTemplate st = StringTemplate.template("model.colony.buildingReady")
		        .add("%colony%", getName())
		        .addName("%building%", buildableType);
			System.out.println("new building " + buildingType + ", msg: " + Messages.message(st));
		}
		
		removeResourcesAfterCompleteBuilding(buildableType);
		buildingQueue.remove(0);
	}
	
	protected Building findBuildingByType(String buildingTypeId) {
		for (Building building : buildings.entities()) {
			if (building.buildingType.equalsId(buildingTypeId)) {
				return building;
			}
		}
		throw new IllegalStateException("can not find building '" + buildingTypeId + "' in colony " + this);
	}
	
    private void removeResourcesAfterCompleteBuilding(BuildableType type) {
    	for (RequiredGoods requiredGoods : type.requiredGoods.entities()) {
    		goodsContainer.decreaseGoodsQuantity(requiredGoods.goodsType, requiredGoods.amount);
    	}
	}

	/**
     * Return the reason why the give <code>BuildableType</code> can
     * not be built.
     *
     * @param buildableType A <code>BuildableType</code> to build.
     * @return A <code>NoBuildReason</code> value decribing the failure,
     *     including <code>NoBuildReason.NONE</code> on success.
     */
	public NoBuildReason getNoBuildReason(BuildableType item) {
		if (item == null) {
			return NoBuildReason.NOT_BUILDING;
		} else if (item.doesNotNeedGoodsToBuild()) {
			return NoBuildReason.NOT_BUILDABLE;
		} else if (item.getRequiredPopulation() > getColonyUnitsCount()) {
			return NoBuildReason.POPULATION_TOO_SMALL;
		} else if (item.hasAbility(Ability.HAS_PORT) && !isCoastland()) {
			return NoBuildReason.COASTAL;
		} else {
			if (!colonyUpdatableFeatures.hasAbilitiesRequiredFrom(item)) {
				return NoBuildReason.MISSING_ABILITY;
			}
		}
		if (item.isBuildingType()) {
			if (!isBuildingCanBeBuiltBecauseOfLevel((BuildingType) item)) {
				return NoBuildReason.WRONG_UPGRADE;
			}
		}
		if (item.isUnitType()) {
			if (UnitType.WAGON_TRAIN.equals(item.getId())) {
				if (owner.unitTypeCount((UnitType) item) >= owner.settlements.size()) {
					return NoBuildReason.LIMIT_EXCEEDED;
				}
			}
			if (!colonyUpdatableFeatures.canApplyAbilityToObject(Ability.BUILD, (UnitType) item)) {
				return NoBuildReason.MISSING_BUILD_ABILITY;
			}
		}
		return NoBuildReason.NONE;
	}
	
	public int getTurnsToComplete(BuildableType buildableType, ObjectIntMap<String> requiredTurnsForGood) {
		ProductionSummary production = productionSummary();
		GoodsContainer warehouse = getGoodsContainer();
		
		int requiredTurn = -1;
		for (RequiredGoods requiredGood : buildableType.requiredGoods()) {
			int warehouseAmount = warehouse.goodsAmount(requiredGood.getId());
			int productionAmount = production.getQuantity(requiredGood.getId());
			int goodRequiredTurn = NEVER_COMPLETE_BUILD;
			
			if (warehouseAmount < requiredGood.amount) {
				if (productionAmount > 0) {
					int reqToProduce = requiredGood.amount - warehouseAmount;
					goodRequiredTurn = reqToProduce / productionAmount;
					if (reqToProduce % productionAmount != 0) {
						goodRequiredTurn++;
					}
				} else {
					goodRequiredTurn = NEVER_COMPLETE_BUILD;
				}
			} else {
				goodRequiredTurn = 0;
			}
			requiredTurnsForGood.put(requiredGood.getId(), goodRequiredTurn);
			
			if (goodRequiredTurn > requiredTurn) {
				requiredTurn = goodRequiredTurn;
			}
		}
		return requiredTurn;
	}
	
	@Override
	public boolean isContainsTile(Tile tile) {
	    return colonyTiles.containsId(tile);
	}
	
    public static class Xml extends XmlNodeParser {
        public Xml() {
        	addNode(ColonyBuildingQueueItem.class, new ObjectFromNodeSetter<Colony, ColonyBuildingQueueItem>() {
				@Override
				public void set(Colony target, ColonyBuildingQueueItem entity) {
					target.buildingQueue.add(entity);
				}
			});
            addNode(GoodsContainer.class, "goodsContainer");
            addNodeForMapIdEntities("buildings", Building.class);
            addNodeForMapIdEntities("colonyTiles", ColonyTile.class);
        }
        
        @Override
        public void startElement(XmlNodeAttributes attr) {
            String strAttribute = attr.getStrAttribute("settlementType");
            Player owner = game.players.getById(attr.getStrAttribute("owner"));
            
            Colony colony = new Colony(attr.getStrAttribute("id"));
            colony.name = attr.getStrAttribute("name");
            colony.sonsOfLiberty = attr.getIntAttribute("sonsOfLiberty", 0);
            colony.tories = attr.getIntAttribute("tories", 0);
            colony.productionBonus = attr.getIntAttribute("productionBonus", 0);
            colony.liberty = attr.getIntAttribute("liberty", 0);
            colony.immigration = attr.getIntAttribute("immigration", 0);
            colony.tileId = attr.getStrAttribute("tile");
            colony.owner = owner;
            colony.settlementType = owner.nationType().settlementTypes.getById(strAttribute);
            owner.settlements.add(colony);
            
            nodeObject = colony;
        }

        @Override
        public void endElement(String uri, String localName, String qName) throws SAXException {
        	if (qName.equals(tagName())) {
        		((Colony)nodeObject).updateColonyPopulation();
        		((Colony)nodeObject).updateColonyFeatures();
        	}
        }
        
        @Override
        public String getTagName() {
            return tagName();
        }
        
        public static String tagName() {
            return "colony";
        }
    }
}
