package net.sf.freecol.common.model;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import com.badlogic.gdx.utils.ObjectIntMap;
import com.badlogic.gdx.utils.ObjectIntMap.Entry;

import net.sf.freecol.common.model.Unit.UnitState;
import net.sf.freecol.common.model.player.FoundingFather;
import net.sf.freecol.common.model.player.Market;
import net.sf.freecol.common.model.player.MessageNotification;
import net.sf.freecol.common.model.player.Player;
import net.sf.freecol.common.model.player.TransactionEffectOnMarket;
import net.sf.freecol.common.model.specification.Ability;
import net.sf.freecol.common.model.specification.BuildableType;
import net.sf.freecol.common.model.specification.BuildingType;
import net.sf.freecol.common.model.specification.GameOptions;
import net.sf.freecol.common.model.specification.GoodsType;
import net.sf.freecol.common.model.specification.Modifier;
import net.sf.freecol.common.model.specification.RequiredGoods;
import net.sf.freecol.common.model.specification.UnitTypeChange.ChangeType;
import net.sf.freecol.common.util.StringUtils;
import promitech.colonization.Direction;
import promitech.colonization.orders.NewTurnContext;
import promitech.colonization.savegame.ObjectFromNodeSetter;
import promitech.colonization.savegame.XmlNodeAttributes;
import promitech.colonization.savegame.XmlNodeAttributesWriter;
import promitech.colonization.savegame.XmlNodeParser;
import promitech.colonization.ui.resources.Messages;
import promitech.colonization.ui.resources.StringTemplate;

public class Colony extends Settlement {
	public static final int NEVER_COMPLETE_BUILD = -1;
    public static final int LIBERTY_PER_REBEL = 200;
    
	private static final Comparator<Building> BUILDING_GOODS_OUTPUT_CHAIN_LEVEL = new Comparator<Building>() {
		@Override
		public int compare(Building o1, Building o2) {
			return o1.buildingType.getGoodsOutputChainLevel() - o2.buildingType.getGoodsOutputChainLevel();
		}
	};

    /** Reasons for not building a buildable. */
    public static enum NoBuildReason {
        NONE,
        NOT_BUILDING,
        NOT_BUILDABLE,
        POPULATION_TOO_SMALL,
        MISSING_BUILD_ABILITY,
        MISSING_ABILITY,
        WRONG_UPGRADE,
        COASTAL,
        LIMIT_EXCEEDED
    }
    
    GoodsContainer goodsContainer;
    public final MapIdEntities<Building> buildings = new SortedMapIdEntities<Building>(BUILDING_GOODS_OUTPUT_CHAIN_LEVEL);
    public final MapIdEntities<ColonyTile> colonyTiles = new MapIdEntities<ColonyTile>();
    public final List<ColonyBuildingQueueItem> buildingQueue = new ArrayList<ColonyBuildingQueueItem>(); 
	private MapIdEntities<ExportInfo> exportInfos = new MapIdEntities<ExportInfo>();
    
    public final ObjectWithFeatures colonyUpdatableFeatures;
    
    private final ColonyProduction colonyProduction;
    private final MapIdEntities<Unit> colonyWorkers = new MapIdEntities<Unit>();
    private int sonsOfLiberty = 0;
    private int tories = 0;
    private int productionBonus = 0;
    
    /**
     * The number of liberty points.  Liberty points are an
     * abstract game concept.  They are generated by but are not
     * identical to bells, and subject to further modification.
     */
    protected int liberty = 0;
    protected boolean seaConnectionToEurope = false;
    
    private Colony(String id, SettlementType settlementType) {
    	super(id, settlementType);
    	colonyUpdatableFeatures = new ObjectWithFeatures("tmp" + id);
    	colonyProduction = new ColonyProduction(this);
    	
    	// constructor used only by xml parser which create goodsContainer 
    }

    public Colony(IdGenerator idGenerator, SettlementType settlementType) {
		this(idGenerator.nextId(Colony.class), settlementType);
    	goodsContainer = new GoodsContainer();
	}

	public String toString() {
    	return "id=" + getId() + ", name=" + getName();
    }
    
    public int getColonyUnitsCount() {
		return colonyWorkers.size();
	}
    
    public boolean isColonyEmpty() {
    	return colonyWorkers.isEmpty();
    }

    public boolean canReducePopulation() {
    	return getColonyUnitsCount() > colonyUpdatableFeatures.applyModifier(Modifier.MINIMUM_COLONY_SIZE, 0); 
    }
    
    public void updateModelOnWorkerAllocationOrGoodsTransfer() {
    	colonyProduction.setAsNeedUpdate();
    }

    public boolean isUnitInColony(Unit unit) {
        for (Building building : buildings.entities()) {
            if (building.getUnits().containsId(unit)) {
                return true;
            }
        }
        if (isUnitOnTerrain(unit)) {
        	return true;
        }
        return false;
    }
    
	public boolean isUnitOnTerrain(Unit unit) {
	    return unit.isAtLocation(ColonyTile.class);
	}

	public ColonyTile unitWorkingTerrain(Unit unit) {
	    return unit.getLocationOrNull(ColonyTile.class);
	}
	
    public void updateColonyPopulation() {
    	colonyWorkers.clear();
    	for (Building building : buildings.entities()) {
    		colonyWorkers.addAll(building.getUnits());
    	}
    	for (ColonyTile colonyTile : colonyTiles.entities()) {
    		if (colonyTile.hasWorker()) {
    			colonyWorkers.add(colonyTile.getWorker());
    		}
    	}
    	updateSonOfLiberty();
    	updateProductionBonus();
    }
    
    public void updateColonyFeatures() {
    	colonyUpdatableFeatures.clear();
    	if (isCoastland()) {
    		colonyUpdatableFeatures.addAbility(Ability.HAS_PORT_ABILITY);
    	}
    	for (Building b : buildings.entities()) {
    		colonyUpdatableFeatures.addFeatures(b.buildingType);
    	}
    	for (FoundingFather ff : owner.foundingFathers.entities()) {
    	    colonyUpdatableFeatures.addFeatures(ff);
    	}
    	//settlement type jest nulem
    	colonyUpdatableFeatures.addFeatures(settlementType);
    }
    
    public void addModifiersTo(ObjectWithFeatures mods, String modifierCode) {
    	mods.addModifierFrom(colonyUpdatableFeatures, modifierCode);
    }
    
    @Override
    public boolean hasAbility(String abilityCode) {
        return colonyUpdatableFeatures.hasAbility(abilityCode);
    }
    
	@Override
	public int applyModifiers(String modifierCode, int val) {
		return (int)colonyUpdatableFeatures.applyModifier(modifierCode, (float)val);
	}

	public boolean hasBurnableBuildings() {
	    for (Building building : buildings.entities()) {
	    	if (isBuildingBurnable(building)) {
	            return true;
	        }
	    }
	    return false;
	}
	
	public List<Building> createBurnableBuildingsList() {
	    List<Building> burnable = new ArrayList<Building>();
	    for (Building building : buildings.entities()) {
	        if (isBuildingBurnable(building)) {
	            burnable.add(building);
	        }
	    }
	    return burnable;
	}
	
	private boolean isBuildingBurnable(Building building) {
		return !isAutoBuildable(building.buildingType);
	}
	
	public boolean hasStockade() {
		Building stockade = getStockade();
		return stockade != null;
	}
	
	public int getStockadeLevel() {
		Building stockade = getStockade();
		if (stockade != null) {
			return stockade.buildingType.getLevel();
		}
		return 1;
	}
	
    private String getStockadeKey() {
		Building stockade = getStockade();
		if (stockade == null) {
			return null;
		}
		return StringUtils.lastPart(stockade.buildingType.getId(), ".");
    }
    
    private Building getStockade() {
	    for (Building building : buildings.entities()) {
	        if (building.buildingType.hasModifier(Modifier.DEFENCE)) {
	            return building;
	        }
	    }
	    return null;
    }

	public boolean hasSeaConnectionToEurope() {
		return seaConnectionToEurope;
	}
    
	@Override
	public boolean isColony() {
		return true;
	}
	
    public String getImageKey() {
        int count = getColonyUnitsCount();
        String key = (count <= 3) ? "small"
            : (count <= 7) ? "medium"
            : "large";
        String stockade = getStockadeKey();
        if (stockade != null) {
            key += "." + stockade;
        }
        return "model.settlement." + key + ".image";
    }

    public void addWorkerToBuilding(Building building, Unit unit) {
        addWorkerToColony(unit, building);
    }
    
    public void addWorkerToTerrain(ColonyTile aColonyTile, Unit unit) {
    	addWorkerToColony(unit, aColonyTile);
        aColonyTile.tile.changeOwner(owner, this);
        aColonyTile.initMaxPossibleProductionOnTile();
    }

    public void addWorkerToTerrain(ColonyTile aColonyTile, Unit unit, GoodsType goodsType) {
        addWorkerToColony(unit, aColonyTile);
        aColonyTile.tile.changeOwner(owner, this);
        aColonyTile.productionInfo.writeProductionType(aColonyTile.tile.getType().productionInfo, goodsType);
    }
    
    private void addWorkerToColony(Unit worker, UnitLocation unitLocation) {
        worker.setState(UnitState.IN_COLONY);
        UnitRole defaultUnitRole = Specification.instance.unitRoles.getById(UnitRole.DEFAULT_ROLE_ID);
        changeUnitRole(worker, defaultUnitRole);
        worker.changeUnitLocation(unitLocation);
        
        updateModelOnWorkerAllocationOrGoodsTransfer();
    }

    public void determineMaxPotentialProduction(String goodsTypeId, Unit worker, ProductionSummary prod, ProductionSummary cons) {
    	colonyProduction.determineMaxPotentialProduction(goodsTypeId, worker, prod, cons);
    }
    
    public List<GoodMaxProductionLocation> determinePotentialTerrainProductions(Unit unit) {
        if (!unit.isPerson()) {
            return Collections.emptyList();
        }
        ColonyTile terrain = unitWorkingTerrain(unit);
        if (terrain == null) {
        	return Collections.emptyList();
        }
    	return colonyProduction.determinePotentialTerrainProductions(terrain, unit);
    }
    
    public List<GoodMaxProductionLocation> determinePotentialMaxGoodsProduction(Unit unit) {
        if (!unit.isPerson()) {
            return Collections.emptyList();
        }
        return colonyProduction.determinePotentialMaxGoodsProduction(unit);
    }

    public void determinePotentialColonyTilesProduction(Unit worker, List<GoodMaxProductionLocation> potentialProduction) {
    	colonyProduction.determinePotentialColonyTilesProduction(worker, potentialProduction); 
    }
    
    public int colonyWorkerProductionAmount(
		Unit worker, 
		java.util.Map.Entry<GoodsType, Integer> goodsTypeProdAmount) 
    {
    	String outputGoodsId = goodsTypeProdAmount.getKey().getId();
    	Integer outputGoodsInitValue = goodsTypeProdAmount.getValue();
    	
    	int goodQuantity = 0;
        goodQuantity += (int)worker.unitType.applyModifier(outputGoodsId, outputGoodsInitValue);
        goodQuantity = (int)colonyUpdatableFeatures.applyModifier(outputGoodsId, goodQuantity);
        goodQuantity += productionBonus();
        return goodQuantity;
    }
    
    public int colonyWorkerProductionAmount(
		Unit worker, 
		ColonyTile colonyTile, 
		java.util.Map.Entry<GoodsType, Integer> goodsTypeProdAmount) 
    {
    	Integer goodInitValue = goodsTypeProdAmount.getValue();
    	GoodsType prodGoodsType = goodsTypeProdAmount.getKey();
    	
    	int goodsQuantity = (int)worker.unitType.applyModifier(prodGoodsType.getId(), goodInitValue);
    	goodsQuantity = (int)colonyUpdatableFeatures.applyModifier(prodGoodsType.getId(), goodsQuantity);
    	goodsQuantity = colonyTile.tile.applyTileProductionModifier(prodGoodsType.getId(), goodsQuantity);
    	goodsQuantity += productionBonus();
    	return goodsQuantity;
    }
    
    public void changeUnitRole(Unit unit, UnitRole newUnitRole) {
    	if (!newUnitRole.isAvailableTo(unit.unitType, colonyUpdatableFeatures)) {
    		throw new IllegalStateException("can not change role for unit: " + unit + " from " + unit.unitRole + " to " + newUnitRole);
    	}

    	ProductionSummary required = new ProductionSummary();
		int maxAvailableRoleCount = UnitRoleLogic.maximumAvailableRequiredGoods(unit, newUnitRole, goodsContainer, required);
    	unit.changeRole(newUnitRole, maxAvailableRoleCount);
    	goodsContainer.decreaseGoodsQuantity(required);
    }
    
    @Override
    public GoodsContainer getGoodsContainer() {
        return goodsContainer;
    }
    
	@Override
	public void addGoods(String goodsTypeId, int quantity) {
		goodsContainer.increaseGoodsQuantity(goodsTypeId, quantity);
	}
    
    public void increaseWorkersExperience() {
        for (ColonyTile colonyTile : colonyTiles.entities()) {
            if (colonyTile.hasWorker() && !colonyTile.getWorker().isExpert()) {
                Unit worker = colonyTile.getWorker();
                increaseExperienceForWorker(colonyTile, worker, 1);
            }
        }
        for (Building building : buildings.entities()) {
            for (Unit worker : building.getUnits().entities()) {
                if (worker.isExpert()) {
                    continue;
                }
                increaseExperienceForWorker(building, worker, building.getUnits().size());
            }
        }
    }
    
    private void increaseExperienceForWorker(ProductionLocation productionLocation, Unit worker, int prodLocWorkersAmount) {
        ProductionSummary realProduction = productionSummary(productionLocation).realProduction;
        System.out.println("production location [" + productionLocation + "] produce [" + realProduction + "]");
        for (Entry<String> entry : realProduction.entries()) {
            UnitType goodsExpertUnitType = Specification.instance.expertUnitTypeByGoodType.get(entry.key);
            if (goodsExpertUnitType != null && worker.unitType.canBeUpgraded(goodsExpertUnitType, ChangeType.EXPERIENCE)) {
                int experience = entry.value / prodLocWorkersAmount;
                System.out.println("worker [" + worker + "] gain " + experience + " experience to be " + goodsExpertUnitType );
                worker.gainExperience(experience);
                if (worker.isPromotedToExpert()) {
                	updateModelOnWorkerAllocationOrGoodsTransfer();
                	
                	StringTemplate oldName = UnitLabel.getPlainUnitLabel(worker);
                	worker.changeUnitType(goodsExpertUnitType);
                	StringTemplate newName = UnitLabel.getPlainUnitLabel(worker);
                	
                	StringTemplate st = StringTemplate.template("model.unit.experience")
                		.addStringTemplate("%oldName%", oldName)
                		.addStringTemplate("%unit%", newName)
                		.add("%colony%", getName());
                	owner.eventsNotifications.addMessageNotification(st);
                	
                }
            }
        }
    }

    public void removeExcessedStorableGoods() {
        int warehouseCapacity = getWarehouseCapacity();
        for (GoodsType gt : Specification.instance.goodsTypes.entities()) {
            if (!gt.isStorable()) {
                continue;
            }
            if (gt.isFood()) {
                continue;
            }
            int goodsAmount = goodsContainer.goodsAmount(gt);
            if (goodsAmount > warehouseCapacity) {
                int wasteAmount = goodsAmount - warehouseCapacity;
                goodsContainer.decreaseGoodsQuantity(gt, wasteAmount);
                
                StringTemplate st = StringTemplate.template("model.building.warehouseWaste")
                	.add("%colony%", getName())
                	.addName("%goods%", gt)
                	.addAmount("%waste%", wasteAmount);
                owner.eventsNotifications.addMessageNotification(st);
            }
        }
    }
    
    public void handleLackOfResources(NewTurnContext newTurnContext, Game game) {
        int foodProdCons = colonyProduction.globalProductionConsumption().getQuantity(GoodsType.FOOD);
        if (foodProdCons < 0) {
            // food consumption is greater then production
            int quantityToConsume = -foodProdCons;
            int storedAfterConsume = goodsContainer.goodsAmount(GoodsType.FOOD) - quantityToConsume;
            
            if (storedAfterConsume >= 0) {
                int turns = goodsContainer.goodsAmount(GoodsType.FOOD) / quantityToConsume;
                if (turns < 3) {
                	StringTemplate st = StringTemplate.template("model.colony.famineFeared")
        				.add("%colony%", getName())
        				.addAmount("%number%", turns);
                	owner.eventsNotifications.addMessageNotification(st);
                }
            } else {
            	// equalize to zero
            	goodsContainer.increaseGoodsQuantity(GoodsType.FOOD, quantityToConsume);
            	
            	Unit unit = colonyWorkers.first();
            	unit.removeFromLocation();
            	owner.removeUnit(unit);

            	System.out.println("unit[" + unit + "] was removed from colony[" + getName() + "]");
            	
    			updateColonyPopulation();
    			updateModelOnWorkerAllocationOrGoodsTransfer();
            	
    			if (getColonyUnitsCount() > 0) {
    				StringTemplate st = StringTemplate.template("model.colony.colonistStarved").add("%colony%", getName());
    				owner.eventsNotifications.addMessageNotification(st);
    			} else {
    				StringTemplate st = StringTemplate.template("model.colony.colonyStarved").add("%colony%", getName());
    				owner.eventsNotifications.addMessageNotification(st);
    				removeFromMap(game);
    				removeFromPlayer();
    				newTurnContext.setRequireUpdateMapModel();
    			}
            }
        }
        
        for (Building building : buildings.entities()) {
            ProductionConsumption productionSummary = productionSummary(building);

            for (Entry<String> entry : productionSummary.baseProduction.entries()) {
                if (GoodsType.isFoodGoodsType(entry.key)) {
                    continue;
                }
                int quantityToConsume = -entry.value;
                int afterConsume = goodsContainer.goodsAmount(entry.key) - quantityToConsume;
                if (afterConsume == 0) {
                	GoodsType goodsType = Specification.instance.goodsTypes.getById(entry.key);
					StringTemplate st = StringTemplate.template("model.building.notEnoughInput")
                		.add("%colony%", getName())
                		.addName("%inputGoods%", goodsType);
					owner.eventsNotifications.addMessageNotification(st);
                } else {
                    if (afterConsume < quantityToConsume) {
                    	GoodsType goodsType = Specification.instance.goodsTypes.getById(entry.key);
                    	StringTemplate st = StringTemplate.template("model.building.warehouseEmpty")
                    		.add("%colony%", getName())
                    		.addName("%goods%", goodsType)
                    		.addAmount("%level%", quantityToConsume);
                    	owner.eventsNotifications.addMessageNotification(st);
                    }
                }
            }
        }
    }
    
    public void resetLiberty() {
    	this.liberty = 0;
    	this.sonsOfLiberty = 0;
    	this.tories = 0;
    	this.productionBonus = 0;
    }
    
	public void calculateSonsOfLiberty() {
		int oldSonsOfLiberty = sonsOfLiberty;
		ProductionSummary gpc = colonyProduction.globalProductionConsumption();
		int bells = gpc.getQuantity(GoodsType.BELLS);

        System.out.println("calculateSonsOfLiberty: bells: " + bells + ", liberty: " + liberty + ", sonsOfLiberty: " + sonsOfLiberty + ", tories: " + tories);
		
		owner.modifyLiberty(bells);
		liberty = Math.max(0, liberty + bells);
		
		updateSonOfLiberty();
		updateProductionBonus();
        boolean capped = Specification.options.getBoolean(GameOptions.BELL_ACCUMULATION_CAPPED);
        if (capped && sonsOfLiberty >= 100) {
            liberty = LIBERTY_PER_REBEL * getColonyUnitsCount();
        }

		if (sonsOfLiberty / 10 != oldSonsOfLiberty / 10) {
			String templateName = null;
			if (sonsOfLiberty > oldSonsOfLiberty) {
				templateName = "model.colony.SoLIncrease";
			} else {
				templateName = "model.colony.SoLDecrease";
			}
			StringTemplate t = StringTemplate.template(templateName)
					.add("%colony%", this.getName())
					.addAmount("%newSoL%", sonsOfLiberty);
			owner.eventsNotifications.addMessageNotification(t);
		}
        System.out.println("calculateSonsOfLiberty: bells: " + bells + ", liberty: " + liberty + ", sonsOfLiberty: " + sonsOfLiberty + ", tories: " + tories);
	}
    
    public ProductionConsumption productionSummary(ProductionLocation productionLocation) {
    	return colonyProduction.productionConsumptionForObject(productionLocation.getId());
    }
    
    public ProductionSummary productionSummary() {
    	return colonyProduction.globalProductionConsumption();
    }
    
	public void increaseWarehouseByProduction() {
		goodsContainer.increaseGoodsQuantity(productionSummary());
	}
    
	public void reduceTileResourceQuantity(NewTurnContext newTurnContext) {
		for (ColonyTile ct : colonyTiles.entities()) {
			if (ct.hasNotWorker()) {
				continue;
			}
			ProductionConsumption ps = productionSummary(ct);
			for (Entry<String> entry : ps.realProduction.entries()) {
				ResourceType reducedResourceType = ct.tile.reduceTileResourceQuantity(entry.key, entry.value);
				if (reducedResourceType != null) {
					newTurnContext.setRequireUpdateMapModel();
					updateModelOnWorkerAllocationOrGoodsTransfer();

					StringTemplate st = StringTemplate.template("model.tile.resourceExhausted")
						.addName("%resource%", reducedResourceType)
						.add("%colony%", getName());
					owner.eventsNotifications.addMessageNotification(st);
				}
			}
		}
	}
	
    public void initMaxPossibleProductionOnTile(Tile tile) {
    	for (ColonyTile colonyTile : colonyTiles.entities()) {
    		if (colonyTile.equalsId(tile)) {
    		    colonyTile.initMaxPossibleProductionOnTile();
    			updateModelOnWorkerAllocationOrGoodsTransfer();
    		}
    	}
    }
    
    public int getWarehouseCapacity() {
    	return (int)colonyUpdatableFeatures.applyModifier(Modifier.WAREHOUSE_STORAGE, 0);
    }

    public int sonsOfLiberty() {
        return sonsOfLiberty;
    }

    public int rebels() {
        return (int)Math.floor(0.01 * sonsOfLiberty * getColonyUnitsCount());
    }

    public int tories() {
        return tories;
    }

    public int productionBonus() {
        return productionBonus;
    }
    
    /**
     * Update the colony's production bonus.
     *
     * @return True if the bonus changed.
     */
    protected boolean updateProductionBonus() {
        final int veryBadGovernment = Specification.options.getIntValue(GameOptions.VERY_BAD_GOVERNMENT_LIMIT);
        final int badGovernment = Specification.options.getIntValue(GameOptions.BAD_GOVERNMENT_LIMIT);
        final int veryGoodGovernment = Specification.options.getIntValue(GameOptions.VERY_GOOD_GOVERNMENT_LIMIT);
        final int goodGovernment = Specification.options.getIntValue(GameOptions.GOOD_GOVERNMENT_LIMIT);
        int newBonus = (sonsOfLiberty >= veryGoodGovernment) ? 2
            : (sonsOfLiberty >= goodGovernment) ? 1
            : (tories > veryBadGovernment) ? -2
            : (tories > badGovernment) ? -1
            : 0;
        if (productionBonus != newBonus) {
            productionBonus = newBonus;
            return true;
        }
        return false;
    }
    
    private void updateSonOfLiberty() {
        int uc = getColonyUnitsCount();
        sonsOfLiberty = calculateSoLPercentage(uc, liberty);
        tories = uc - rebels();
    }
    
    /**
     * Gets the number of units that would be good to add/remove from this
     * colony.  That is the number of extra units that can be added without
     * damaging the production bonus, or the number of units to remove to
     * improve it.
     *
     * @return The number of units to add to the colony, or if negative
     *      the negation of the number of units to remove.
     */
    public int getPreferredSizeChange() {
        int i, limit, pop = getColonyUnitsCount();
        if (productionBonus < 0) {
            limit = pop;
            for (i = 1; i < limit; i++) {
                if (governmentChange(pop - i) == 1) break;
            }
            return -i;
        } else {
            limit = Specification.options.getIntValue(GameOptions.BAD_GOVERNMENT_LIMIT);
            for (i = 1; i < limit; i++) {
                if (governmentChange(pop + i) == -1) break;
            }
            return i - 1;
        }
    }
    
    /**
     * Returns 1, 0, or -1 to indicate that government would improve,
     * remain the same, or deteriorate if the colony had the given
     * population.
     *
     * @param unitCount The proposed population for the colony.
     * @return 1, 0 or -1.
     */
    public int governmentChange(int unitCount) {
        final int veryBadGovernment = Specification.options.getIntValue(GameOptions.VERY_BAD_GOVERNMENT_LIMIT);
        final int badGovernment = Specification.options.getIntValue(GameOptions.BAD_GOVERNMENT_LIMIT);
        final int veryGoodGovernment = Specification.options.getIntValue(GameOptions.VERY_GOOD_GOVERNMENT_LIMIT);
        final int goodGovernment = Specification.options.getIntValue(GameOptions.GOOD_GOVERNMENT_LIMIT);

        int rebelPercent = calculateSoLPercentage(unitCount, liberty);
        int rebelCount = rebels();
        int loyalistCount = unitCount - rebelCount;

        int result = 0;
        if (rebelPercent >= veryGoodGovernment) { // There are no tories left.
            if (sonsOfLiberty < veryGoodGovernment) {
                result = 1;
            }
        } else if (rebelPercent >= goodGovernment) {
            if (sonsOfLiberty >= veryGoodGovernment) {
                result = -1;
            } else if (sonsOfLiberty < goodGovernment) {
                result = 1;
            }
        } else {
            if (sonsOfLiberty >= goodGovernment) {
                result = -1;
            } else { // Now that no bonus is applied, penalties may.
                if (loyalistCount > veryBadGovernment) {
                    if (tories <= veryBadGovernment) {
                        result = -1;
                    }
                } else if (loyalistCount > badGovernment) {
                    if (tories <= badGovernment) {
                        result = -1;
                    } else if (tories > veryBadGovernment) {
                        result = 1;
                    }
                } else {
                    if (tories > badGovernment) {
                        result = 1;
                    }
                }
            }
        }
        return result;
    }
    
    /**
     * Calculate the SoL membership percentage of the colony based on the
     * number of colonists and liberty.
     *
     * @param uc The proposed number of units in the colony.
     * @param liberty The amount of liberty.
     * @return The percentage of SoLs, negative if not calculable.
     */
    private int calculateSoLPercentage(int uc, int liberty) {
        if (uc <= 0) {
            return -1;
        }
        float membership = (liberty * 100.0f) / (LIBERTY_PER_REBEL * uc);
        membership = owner.getFeatures().applyModifier(Modifier.SOL, membership);
        
        if (membership < 0.0f) {
            membership = 0.0f;
        } else if (membership > 100.0f) {
            membership = 100.0f;
        }
        return (int)membership;
    }
    
    public void createColonyTiles(Map map, Tile centerColonyTile) {
    	this.tile = centerColonyTile;
    	this.coastland = this.tile.isOnSeaSide();
    	
		ColonyTile centerTile = new ColonyTile(tile);
		colonyTiles.add(centerTile);
		centerTile.initMaxPossibleProductionOnTile();
		
    	for (Direction d : Direction.allDirections) {
    		Tile neighbourTile = map.getTile(tile, d);
    		if (neighbourTile == null) {
    			continue;
    		}
    		colonyTiles.add(new ColonyTile(neighbourTile));
    	}
    }
    
    public void initColonyTilesTile(Tile colonyTile, Map map) {
    	this.coastland = this.tile.isOnSeaSide();
    	
    	for (ColonyTile ct : colonyTiles.entities()) {
            boolean foundTileForColonyTile = false; 
            for (Direction direction : Direction.allDirections) {
                if (ct.equalsId(colonyTile)) {
                    ct.tile = colonyTile;
                    foundTileForColonyTile = true;
                    break;
                }
                Tile borderTile = map.getTile(colonyTile.x, colonyTile.y, direction);
                if (ct.equalsId(borderTile)) {
                    ct.tile = borderTile;
                    foundTileForColonyTile = true;
                    break;
                }
            }
            if (foundTileForColonyTile == false) {
                throw new IllegalStateException("can not find Tile for ColonyTile: " + ct);
            }
        }
    }
    
    public void addItemToBuildingQueue(ColonyBuildingQueueItem item) {
    	buildingQueue.add(item);
    }
    
    public void removeItemFromBuildingQueue(ColonyBuildingQueueItem item) {
        buildingQueue.remove(item);
    }
    
	public BuildableType getFirstItemInBuildingQueue() {
        if (buildingQueue.isEmpty()) {
            return null;
        }
        return buildingQueue.get(0).getType();
	}
	
	public void ifPossibleAddFreeBuildings() {
		for (BuildingType buildingType : Specification.instance.buildingTypes.entities()) {
			if (isAutoBuildableInColony(buildingType)) {
				ifPossibleAddFreeBuilding(buildingType);
			}
		}
	}
	
	public void ifPossibleAddFreeBuilding(BuildingType buildingType) {
		if (isBuildingAlreadyBuilt(buildingType)) {
			return;
		}
		NoBuildReason noBuildReason = getNoBuildReason(buildingType);
		if (noBuildReason != NoBuildReason.NONE) {
			System.out.println("addFreeBuilding[" + owner.getId() + "] reason " + noBuildReason);
			return;
		}
    	for (ColonyBuildingQueueItem item : buildingQueue) {
    		if (buildingType.equalsId(item.getId())) {
    			buildingQueue.remove(item);
    			break;
    		}
    	}		
		finishBuilding(buildingType);
	}
	
    public void buildableBuildings(List<ColonyBuildingQueueItem> items) {
    	for (BuildingType bt : Specification.instance.buildingTypes.entities()) {
    	    NoBuildReason noBuildReason = getNoBuildReason(bt);
    	    if (noBuildReason != NoBuildReason.NONE) {
    	        System.out.println("" + bt + ": " + noBuildReason);
    	        continue;
    	    }
    		
    		if (isOnBuildingQueue(bt)) {
    		    System.out.println("" + bt + " already on building queue list");
    		    continue;
    		}
    		
    		if (isBuildingAlreadyBuilt(bt)) {
    		    System.out.println("" + bt + " has already built");
    		    continue;
    		}
    		items.add(new ColonyBuildingQueueItem(bt));
    	}
    }
    
    public void buildableUnits(List<ColonyBuildingQueueItem> items) {
    	for (UnitType unitType : Specification.instance.unitTypes.entities()) {
    	    NoBuildReason noBuildReason = getNoBuildReason(unitType);
            if (noBuildReason != NoBuildReason.NONE) {
                System.out.println("can not build " + unitType + " because of " + noBuildReason);
                continue;
            }
    		items.add(new ColonyBuildingQueueItem(unitType));
    	}
    }
    
    private boolean isBuildingCanBeBuiltBecauseOfLevel(BuildingType buildingType) {
    	for (Building building : buildings.entities()) {
    		if (building.buildingType.isTheSameRoot(buildingType)) {
    			if (building.buildingType.canUpgradeTo(buildingType)) {
    				return true;
    			} else {
    				return false;
    			}
    		}
    	}
    	// does not find building
    	return buildingType.isRoot();
    }
    
    public boolean isBuildingAlreadyBuilt(BuildingType buildingType) {
    	for (Building building : buildings.entities()) {
    		if (building.buildingType.equalsId(buildingType)) {
    			return true;
    		}
    	}
    	return false;
    }
    
    private boolean isOnBuildingQueue(BuildingType buildingType) {
    	for (ColonyBuildingQueueItem item : buildingQueue) {
    		if (buildingType.equalsId(item.getId())) {
    			return true;
    		}
    	}
    	return false;
    }
    
	public int getPriceForBuilding(BuildableType buildableType) {
		Market market = owner.market();
		
		int sum = 0;
		for (RequiredGoods rg : buildableType.requiredGoods()) {
			if (market.hasArrears(rg.goodsType)) {
				return Integer.MAX_VALUE;
			}
			int warehouseGoodsAmount = goodsContainer.goodsAmount(rg.getId());
			if (rg.amount > warehouseGoodsAmount) {
				int requireGoods = rg.amount - warehouseGoodsAmount;
				sum += market.buildingGoodsPrice(rg.goodsType, requireGoods);
			}
		}
		return sum;
	}

	public void payForBuilding(BuildableType buildableType, Game game) {
		if (!Specification.options.getBoolean(GameOptions.PAY_FOR_BUILDING)) {
			throw new IllegalStateException("Pay for building is disabled");
		}
		
		Market ownerMarket = owner.market();
		for (RequiredGoods requiredGood : buildableType.requiredGoods()) {
			int reqDiffAmount = requiredGood.amount - goodsContainer.goodsAmount(requiredGood.goodsType);
			if (reqDiffAmount <= 0) {
				continue;
			}
			TransactionEffectOnMarket effectOnMarket = ownerMarket.buyGoodsForBuilding(game, owner, requiredGood.goodsType, reqDiffAmount);
			goodsContainer.increaseGoodsQuantity(requiredGood.goodsType, reqDiffAmount);
			
			if (effectOnMarket.isMarketPriceChanged()) {
				owner.eventsNotifications.addMessageNotification(MessageNotification.createGoodsPriceChangeNotification(owner, effectOnMarket));
			}
		}
		updateModelOnWorkerAllocationOrGoodsTransfer();
	}
	
	public void increaseColonySize() {
	    int foodGoodsAmount = goodsContainer.goodsAmount(GoodsType.FOOD);
	    if (foodGoodsAmount >= FOOD_PER_COLONIST) {
	        goodsContainer.decreaseGoodsQuantity(GoodsType.FOOD, FOOD_PER_COLONIST);
	        
	        UnitType freeColonistUnitType = Specification.instance.unitTypes.getById(UnitType.FREE_COLONIST);
	        UnitFactory.create(freeColonistUnitType, owner, tile);
	        
            StringTemplate st = StringTemplate.template("model.colony.newColonist")
                        .add("%colony%", getName());
            owner.eventsNotifications.addMessageNotification(st);
	    }
	}
	
	public void buildBuildings(NewTurnContext newTurnContext) {
	    BuildableType buildableType = getFirstItemInBuildingQueue();
		if (buildableType == null) {
			return;
		}
		ObjectIntMap<String> requiredTurnsForGoods = new ObjectIntMap<String>(2);
		int turnsToGatherResourcesForBuild = getTurnsToComplete(buildableType, requiredTurnsForGoods);
		if (turnsToGatherResourcesForBuild == NEVER_COMPLETE_BUILD) {
			neverFinishBuildingNotification(buildableType, requiredTurnsForGoods);
			return;
		} 
		if (turnsToGatherResourcesForBuild == 0) {
			NoBuildReason noBuildReason = getNoBuildReason(buildableType);
			if (NoBuildReason.NONE != noBuildReason) {
				finishBuildingProblemNotification(buildableType, noBuildReason);
			} else {
				finishBuilding(newTurnContext, buildableType);
			}
		}
	}

    private void finishBuildingProblemNotification(BuildableType buildableType, NoBuildReason noBuildReason) {
        StringTemplate st;
        switch (noBuildReason) {
        case LIMIT_EXCEEDED:
        	st = StringTemplate.template("model.limit.wagonTrains.description");
        	break;
        case POPULATION_TOO_SMALL:
        	st = StringTemplate.template("model.colony.buildNeedPop")
                .add("%colony%", getName())
                .addName("%building%", buildableType);
        	break;
        default:
        	st = StringTemplate.template("colonyPanel.unbuildable")
        		.add("%colony%", getName())
        		.addName("%object%", buildableType);
        	break;
        }
        System.out.println("" + buildableType + " no build reason '" + noBuildReason + "'");
        owner.eventsNotifications.addMessageNotification(st);
    }

    private void neverFinishBuildingNotification(BuildableType buildableType, ObjectIntMap<String> requiredTurnsForGoods) {
        for (RequiredGoods requiredGood : buildableType.requiredGoods()) {
        	int turnsForGoodsType = requiredTurnsForGoods.get(requiredGood.getId(), -1);
        	if (turnsForGoodsType == NEVER_COMPLETE_BUILD) {
        		int amount = requiredGood.amount - goodsContainer.goodsAmount(requiredGood.getId());
        		
        		StringTemplate st = StringTemplate.template("model.colony.buildableNeedsGoods")
        			.addName("%goodsType%", requiredGood.getId())
        			.addAmount("%amount%", amount)
        			.add("%colony%", getName())
        			.addName("%buildable%", buildableType.getId());
        		owner.eventsNotifications.addMessageNotification(st);
        		break;
        	}
        }
    }

	private void finishBuilding(NewTurnContext newTurnContext, BuildableType buildableType) {
		if (buildableType.isUnitType()) {
			Unit unit = UnitFactory.create((UnitType)buildableType, owner, tile);
			
			StringTemplate unitNameSt = UnitLabel.getPlainUnitLabel(unit);
			StringTemplate st = StringTemplate.template("model.colony.unitReady")
				.add("%colony%", getName())
				.addStringTemplate("%unit%", unitNameSt);
			owner.eventsNotifications.addMessageNotification(st);
		}
		if (buildableType.isBuildingType()) {
			BuildingType buildingType = (BuildingType)buildableType;
			finishBuilding(buildingType);
			
			if (buildableType.hasModifier(Modifier.DEFENCE)) {
				newTurnContext.setRequireUpdateMapModel();
			}
			StringTemplate st = StringTemplate.template("model.colony.buildingReady")
		        .add("%colony%", getName())
		        .addName("%building%", buildableType);
			System.out.println("new building " + buildingType + ", msg: " + Messages.message(st));
			owner.eventsNotifications.addMessageNotification(st);
		}
		
		removeResourcesAfterCompleteBuilding(buildableType);
		buildingQueue.remove(0);
	}
	
	private Building finishBuilding(BuildingType buildingType) {
		BuildingType from = buildingType.getUpgradesFrom();
		Building building;
		if (from != null) {
			building = findBuildingByType(from.getId());
			building.upgrade(buildingType);
		} else {
			building = new Building(Game.idGenerator, buildingType);
			buildings.add(building);
		}
		updateColonyFeatures();
		updateColonyPopulation();
		updateModelOnWorkerAllocationOrGoodsTransfer();
		return building;
	}
	
	public Building addBuilding(final BuildingType buildingType) {
		Building building = findBuildingByBuildingTypeHierarchy(buildingType);
		if (building != null) {
			building.upgrade(buildingType);
		} else {
			building = new Building(Game.idGenerator, buildingType);
			buildings.add(building);
		}
		return building;
	}
	
	public void removeBuilding(final String buildingTypeId) {
		Building building = findBuildingByTypeOrNull(buildingTypeId);
		if (building != null) {
			buildings.removeId(building);
		}
	}
	
	protected Building findBuildingByBuildingTypeHierarchy(final BuildingType buildingType) {
		Building foundBuilding = null;
		BuildingType bt = buildingType;
		
		while (bt != null) {
			foundBuilding = findBuildingByTypeOrNull(bt.getId());
			if (foundBuilding != null) {
				break;
			}
			bt = bt.getUpgradesFrom();
		}
		return foundBuilding;
	}
	
	public UnitLocation findUnitLocationById(String unitLocationId) {
		ColonyTile colonyTile = colonyTiles.getByIdOrNull(unitLocationId);
		if (colonyTile != null) {
			return colonyTile;
		}
		return buildings.getByIdOrNull(unitLocationId);
	}
	
	public Building findBuildingByType(String buildingTypeId) {
		Building building = findBuildingByTypeOrNull(buildingTypeId);
		if (building == null) {
			throw new IllegalStateException("can not find building '" + buildingTypeId + "' in colony " + this);
		}
		return building;
	}
	
	protected Building findBuildingByTypeOrNull(String buildingTypeId) {
		for (Building building : buildings.entities()) {
			if (building.buildingType.equalsId(buildingTypeId)) {
				return building;
			}
		}
		return null;
	}
	
    private void removeResourcesAfterCompleteBuilding(BuildableType type) {
    	for (RequiredGoods requiredGoods : type.requiredGoods.entities()) {
    		goodsContainer.decreaseGoodsQuantity(requiredGoods.goodsType, requiredGoods.amount);
    	}
	}

    public void damageBuilding(Building building) {
    	if (building.buildingType.isRoot()) {
    		MapIdEntities<Unit> ejectWorkers = new MapIdEntities<Unit>(building.getUnits());
    		buildings.removeId(building);
    		
    		updateColonyFeatures();
    		
    		for (ColonyTile ct : colonyTiles.entities()) {
    			if (ct.hasWorker() && isTileLocked(ct.tile)) {
    				ejectWorkers.add(ct.getWorker());
    			}
    		}
    		for (Building b : buildings.entities()) {
    			if (b.getUnits().isNotEmpty()) {
    				b.getWorkersToEject(ejectWorkers);
    			}
    		}
    		
    		ejectWorkers(ejectWorkers);
    	} else if (isBuildingBurnable(building)) {
    		MapIdEntities<Unit> ejectWorkers = building.damageBuilding();
    		ejectWorkers(ejectWorkers);
    	} else {
    		return;
    	}
    	
		updateColonyFeatures();
		updateColonyPopulation();
		updateModelOnWorkerAllocationOrGoodsTransfer();
    }
    
    private void ejectWorkers(MapIdEntitiesReadOnly<Unit> ejectWorkers) {
    	if (ejectWorkers.isNotEmpty()) {
    		for (Unit ejectedWorker : ejectWorkers.entities()) {
    			boolean foundBuilding = false;
    			for (Building b : buildings.entities()) {
    				if (b.canAddWorker(ejectedWorker)) {
    					foundBuilding = true;
    					ejectedWorker.changeUnitLocation(b);
    				}
    			}
    			if (!foundBuilding) {
    				ejectedWorker.changeUnitLocation(tile);
    			}
    		}
    	}
    }
    
	/**
     * Return the reason why the give <code>BuildableType</code> can
     * not be built.
     *
     * @param buildableType A <code>BuildableType</code> to build.
     * @return A <code>NoBuildReason</code> value decribing the failure,
     *     including <code>NoBuildReason.NONE</code> on success.
     */
	public NoBuildReason getNoBuildReason(BuildableType item) {
		if (item == null) {
			return NoBuildReason.NOT_BUILDING;
		} else if (item.doesNotNeedGoodsToBuild()) {
			return NoBuildReason.NOT_BUILDABLE;
		} else if (item.getRequiredPopulation() > getColonyUnitsCount()) {
			return NoBuildReason.POPULATION_TOO_SMALL;
		} else if (item.hasAbility(Ability.HAS_PORT) && !isCoastland()) {
			return NoBuildReason.COASTAL;
		} else {
			if (!colonyUpdatableFeatures.hasAbilitiesRequiredFrom(item)) {
				return NoBuildReason.MISSING_ABILITY;
			}
		}
		if (item.isBuildingType()) {
			if (!isBuildingCanBeBuiltBecauseOfLevel((BuildingType) item)) {
				return NoBuildReason.WRONG_UPGRADE;
			}
		}
		if (item.isUnitType()) {
			if (UnitType.WAGON_TRAIN.equals(item.getId())) {
				if (owner.unitTypeCount((UnitType) item) >= owner.settlements.size()) {
					return NoBuildReason.LIMIT_EXCEEDED;
				}
			}
			if (!colonyUpdatableFeatures.canApplyAbilityToObject(Ability.BUILD, item)) {
				return NoBuildReason.MISSING_BUILD_ABILITY;
			}
		}
		return NoBuildReason.NONE;
	}
	
	public int getTurnsToComplete(BuildableType buildableType, ObjectIntMap<String> requiredTurnsForGood) {
		ProductionSummary production = productionSummary();
		GoodsContainer warehouse = getGoodsContainer();
		
		int requiredTurn = -1;
		for (RequiredGoods requiredGood : buildableType.requiredGoods()) {
			int warehouseAmount = warehouse.goodsAmount(requiredGood.getId());
			int productionAmount = production.getQuantity(requiredGood.getId());
			int goodRequiredTurn = NEVER_COMPLETE_BUILD;
			
			if (warehouseAmount < requiredGood.amount) {
				if (productionAmount > 0) {
					int reqToProduce = requiredGood.amount - warehouseAmount;
					goodRequiredTurn = reqToProduce / productionAmount;
					if (reqToProduce % productionAmount != 0) {
						goodRequiredTurn++;
					}
				} else {
					goodRequiredTurn = NEVER_COMPLETE_BUILD;
				}
			} else {
				goodRequiredTurn = 0;
			}
			requiredTurnsForGood.put(requiredGood.getId(), goodRequiredTurn);
			
			if (goodRequiredTurn > requiredTurn) {
				requiredTurn = goodRequiredTurn;
			}
		}
		return requiredTurn;
	}
	
	protected void initDefaultBuildings() {
    	for (BuildingType buildingType : Specification.instance.buildingTypes.entities()) {
    		if (isAutoBuildable(buildingType)) {
    			buildings.add(new Building(Game.idGenerator, buildingType));
    			colonyProduction.setAsNeedUpdate();
    		}
    	}
	}
	
	private boolean isAutoBuildable(BuildingType buildingType) {
	    return buildingType.isAutomaticBuild() || isAutoBuildableInColony(buildingType);
	}
	
    private boolean isAutoBuildableInColony(BuildingType buildingType) {
    	float modified = owner.getFeatures().applyModifier(Modifier.BUILDING_PRICE_BONUS, 100, buildingType);
    	NoBuildReason noBuildReason = getNoBuildReason(buildingType);
    	return modified == 0f && noBuildReason == NoBuildReason.NONE;
    }
	
    public void initColonyBuilderUnit(Unit builder) {
    	updateModelOnWorkerAllocationOrGoodsTransfer();
    	
    	GoodMaxProductionLocation maxProd = null;
        for (GoodsType gt : Specification.instance.goodsTypes.entities()) {
            if (gt.isFarmed()) {
            	GoodMaxProductionLocation prod = colonyProduction.maxProductionFromTile(gt, builder);
            	if (prod != null && (maxProd == null || maxProd.hasLessProduction(prod.getProduction()))) {
            		maxProd = prod;
            	}
            }
        }
    	if (maxProd != null) {
    		addWorkerToTerrain(maxProd.getColonyTile(), builder);
    	} else {
    		Building townHall = findBuildingByType(BuildingType.TOWN_HALL);
    		addWorkerToBuilding(townHall, builder);
    	}
    	updateColonyPopulation();
    }
    
	@Override
	public boolean isContainsTile(Tile tile) {
	    return colonyTiles.containsId(tile);
	}
	
	public boolean isTileLockedBecauseNoDock(Tile tile) {
		if (tile.getType().isWater() && !colonyUpdatableFeatures.hasAbility(Ability.PRODUCE_IN_WATER)) {
			return true;
		}
		return false;
	}
	
	/**
	 * Is tile locked for colony worker. 
	 */
	public boolean isTileLocked(Tile tile) {
		if (isTileLockedBecauseNoDock(tile)) {
			return true;
		}
		if (tile.hasLostCityRumour()) {
			return true;
		}
		if (tile.getOwner() != null) {
			if (tile.getOwner().isIndian()) {
				return !owner.foundingFathers.containsId(FoundingFather.PETER_MINUIT);
			} else {
				if (tile.getOwningSettlementId() != null) {
					if (tile.isOwnBySettlement(this)) {
						return false;
					}
					if (tile.hasWorkerOnTile()) {
						return true;
					}
				} 
			}
		}
		return false;
	}

	public boolean hasLootableGoods() {
	    Specification spec = Specification.instance;
	    for (Entry<String> goods : goodsContainer.entries()) {
	        if (goods.value > 0 && spec.goodsTypes.getById(goods.key).isStorable()) {
	            return true;
	        }
        }
	    return false;
	}
	
	public List<GoodsType> createLootableGoodsList() {
	    List<GoodsType> lootable = new ArrayList<GoodsType>();
	    Specification spec = Specification.instance;
        for (Entry<String> goods : goodsContainer.entries()) {
            GoodsType gt = spec.goodsTypes.getById(goods.key);
            if (goods.value > 0 && gt.isStorable()) {
                lootable.add(gt);
            }
        }
	    return lootable;
	}
	
	public Collection<Unit> settlementWorkers() {
		return colonyWorkers.entities();
	}
	
	@Override
	public MapIdEntitiesReadOnly<Unit> getUnits() {
		return colonyWorkers;
	}

    @Override
    public void addUnit(Unit unit) {
        throw new IllegalStateException("should add unit directly to building or colony tile");
    }

    @Override
    public void removeUnit(Unit unit) {
        throw new IllegalStateException("should remove unit directly from building or colony tile");
    }
	
	public void changeOwner(Player newOwner) {
		Player oldOwner = owner;
		super.changeOwner(newOwner);
		
		if (oldOwner != null) {
			for (ColonyTile colonyTile : colonyTiles.entities()) {
				if (oldOwner.equalsId(colonyTile.tile.getOwner()) && colonyTile.tile.isOwnBySettlement(this)) {
					colonyTile.tile.changeOwner(newOwner);
				}
			}
		}
		
		buildingQueue.clear();
		ifPossibleAddFreeBuildings();
	}
	
	public ExportInfo exportInfo(GoodsType goodsType) {
		ExportInfo info = exportInfos.getByIdOrNull(goodsType.getId());
		if (info == null) {
			info = new ExportInfo(goodsType.getId());
			exportInfos.add(info);
		}
		return info;
	}

	public void exportGoods(Game game) {
		if (!hasAbility(Ability.EXPORT)) {
			return;
		}
		
		for (GoodsType goodsType : Specification.instance.goodsTypes.entities()) {
			if (!goodsType.isStorable()) {
				continue;
			}
			ExportInfo exportInfo = exportInfo(goodsType);
			if (!exportInfo.isExport() || !owner.market().canTradeInCustomHouse(game, owner, goodsType.getId())) {
				continue;
			}
			int exportAmount = goodsContainer.goodsAmount(goodsType) - exportInfo.getExportLevel();
			if (exportAmount <= 0) {
				continue;
			}
			TransactionEffectOnMarket transaction = owner.market().sellGoods(game, owner, goodsType, exportAmount);
			goodsContainer.decreaseGoodsQuantity(goodsType, exportAmount);
			
			System.out.println("exportGoods[" + owner.getId() + "].export " 
				+ goodsType.getId() + " " + transaction.quantity 
				+ " for price: " + transaction.netPrice
			);
		}
	}
	
	public int maxGoodsAmountToFillWarehouseCapacity(String goodsTypeId, int goodsAmount) {
		int freeSpace = getWarehouseCapacity() - goodsContainer.goodsAmount(goodsTypeId);
		if (freeSpace < 0) {
			freeSpace = 0;
		}
		if (freeSpace < goodsAmount) {
			return freeSpace;
		}
		return goodsAmount;
	}
	
    public static class Xml extends XmlNodeParser<Colony> {
        private static final String ATTR_LIBERTY = "liberty";
		private static final String ATTR_PRODUCTION_BONUS = "productionBonus";
		private static final String ATTR_TORIES = "tories";
		private static final String ATTR_SONS_OF_LIBERTY = "sonsOfLiberty";
		private static final String ATTR_NAME = "name";
		private static final String ATTR_OWNER = "owner";
		private static final String ATTR_SETTLEMENT_TYPE = "settlementType";
		private static final String ATTR_SEA_CONNECTION_TO_EUROPE = "seaConnectionToEurope";

		public Xml() {
        	addNode(ColonyBuildingQueueItem.class, new ObjectFromNodeSetter<Colony, ColonyBuildingQueueItem>() {
				@Override
				public void set(Colony target, ColonyBuildingQueueItem entity) {
					target.buildingQueue.add(entity);
				}
				@Override
				public void generateXml(Colony source, ChildObject2XmlCustomeHandler<ColonyBuildingQueueItem> xmlGenerator) throws IOException {
					xmlGenerator.generateXmlFromCollection(source.buildingQueue);
				}
			});
        	
        	addNode(ExportInfo.class, new ObjectFromNodeSetter<Colony, ExportInfo>() {
				@Override
				public void set(Colony target, ExportInfo entity) {
					target.exportInfos.add(entity);
				}

				@Override
				public void generateXml(Colony source, ChildObject2XmlCustomeHandler<ExportInfo> xmlGenerator) throws IOException {
					for (ExportInfo exportInfo : source.exportInfos.entities()) {
						if (exportInfo.isNotDefaultSettings()) {
							xmlGenerator.generateXml(exportInfo);
						}
					}
				}
        	});
        	
            addNode(GoodsContainer.class, "goodsContainer");
            addNodeForMapIdEntities("buildings", Building.class);
            addNodeForMapIdEntities("colonyTiles", ColonyTile.class);
        }
        
        @Override
        public void startElement(XmlNodeAttributes attr) {
            String settlementTypeStr = attr.getStrAttribute(ATTR_SETTLEMENT_TYPE);
            Player owner = game.players.getById(attr.getStrAttribute(ATTR_OWNER));
            
            Colony colony = new Colony(
        		attr.getStrAttribute(ATTR_ID),
        		owner.nationType().settlementTypes.getById(settlementTypeStr)
    		);
            colony.name = attr.getStrAttribute(ATTR_NAME);
            colony.sonsOfLiberty = attr.getIntAttribute(ATTR_SONS_OF_LIBERTY, 0);
            colony.tories = attr.getIntAttribute(ATTR_TORIES, 0);
            colony.productionBonus = attr.getIntAttribute(ATTR_PRODUCTION_BONUS, 0);
            colony.liberty = attr.getIntAttribute(ATTR_LIBERTY, 0);
            colony.owner = owner;
            colony.seaConnectionToEurope = attr.getBooleanAttribute(ATTR_SEA_CONNECTION_TO_EUROPE, false);
            owner.settlements.add(colony);
            
            nodeObject = colony;
        }

        @Override
        public void startWriteAttr(Colony colony, XmlNodeAttributesWriter attr) throws IOException {
        	attr.setId(colony);
        	
        	attr.set(ATTR_SETTLEMENT_TYPE, colony.settlementType);
        	attr.set(ATTR_OWNER, colony.owner);
            
        	attr.set(ATTR_NAME, colony.name);
        	attr.set(ATTR_SONS_OF_LIBERTY, colony.sonsOfLiberty, 0);
        	attr.set(ATTR_TORIES, colony.tories, 0);
        	attr.set(ATTR_PRODUCTION_BONUS, colony.productionBonus);
        	attr.set(ATTR_LIBERTY, colony.liberty, 0);
        	attr.set(ATTR_SEA_CONNECTION_TO_EUROPE, colony.seaConnectionToEurope, false);
        }
        
        @Override
        public String getTagName() {
            return tagName();
        }
        
        public static String tagName() {
            return "colony";
        }
    }
}
